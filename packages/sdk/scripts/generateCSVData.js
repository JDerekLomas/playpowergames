const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');

// Function to parse CSV data into a QuestionBank
function parseCSVToQuestionBank(csvData, bankName) {
    const records = parse(csvData, {
        columns: true,
        skip_empty_lines: true
    });

    const questions = records.map(record => {
        // Ensure required fields are present
        if (
            !('Operand 1' in record) ||
            !('Operand 2' in record) ||
            !('Answer' in record)
        ) {
            throw new Error(`Missing required fields in CSV row: ${JSON.stringify(record)}`);
        }

        // Map all fields, converting keys to camelCase
        const question = {};
        for (const [key, value] of Object.entries(record)) {
            // Convert to camelCase
            const camelKey = key
              .replace(/ ([a-z])/g, g => g[1].toUpperCase()) // Capitalize letters after spaces
              .replace(/ /g, '') // Remove all spaces
              .replace(/^([A-Z])/, g => g.toLowerCase()); // Convert the first letter to lowercase
            question[camelKey] = value;
        }
        return question;
    });

    return {
        name: bankName,
        questions
    };
}

// Function to convert a file name to a valid JavaScript identifier
function toValidIdentifier(fileName) {
    // Remove file extension if present
    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, '');

    // If the name starts with a number, prefix it with 'bank_'
    if (/^\d/.test(nameWithoutExt)) {
        return `bank_${nameWithoutExt}`;
    }

    // Replace any non-alphanumeric characters with underscores
    return nameWithoutExt.replace(/[^a-zA-Z0-9]/g, '_');
}

// Function to generate TypeScript code from a QuestionBank
function generateTypeScriptCode(bank) {
    const questionsString = bank.questions
        .map(q => {
            // Dynamically generate all fields
            const fields = Object.entries(q)
                .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)
                .join(', ');
            return `    { ${fields} }`;
        })
        .join(',\n');

    // Use the original bank name for the 'name' property, but use a valid identifier for the variable name
    const validIdentifier = toValidIdentifier(bank.name);

    return `// Auto-generated from ${bank.name}.csv
// Do not edit this file directly

import { QuestionBank } from '../index';

export const ${validIdentifier}: QuestionBank = {
  name: '${bank.name}',
  questions: [
${questionsString}
  ]
};
`;
}

// Function to recursively delete a directory
function deleteDirectoryRecursive(directoryPath) {
    if (fs.existsSync(directoryPath)) {
        fs.readdirSync(directoryPath).forEach((file) => {
            const curPath = path.join(directoryPath, file);
            if (fs.lstatSync(curPath).isDirectory()) {
                // Recursive call for directories
                deleteDirectoryRecursive(curPath);
            } else {
                // Delete file
                fs.unlinkSync(curPath);
            }
        });
        // Delete the directory itself
        fs.rmdirSync(directoryPath);
        console.log(`Deleted directory: ${directoryPath}`);
    }
}

// Main function to process all CSV files
function generateQuestionBanks() {
    const questionBankDir = path.join(__dirname, '../src/question_bank');
    const outputDir = path.join(__dirname, '../src/question_bank/generated');

    // Delete the output directory if it exists to avoid mixing old and new banks
    if (fs.existsSync(outputDir)) {
        console.log('Cleaning up existing generated files...');
        deleteDirectoryRecursive(outputDir);
    }

    // Create output directory
    fs.mkdirSync(outputDir, { recursive: true });
    console.log(`Created output directory: ${outputDir}`);

    // Get all CSV files
    const files = fs.readdirSync(questionBankDir)
        .filter(file => file.endsWith('.csv'));

    if (files.length === 0) {
        console.log('No CSV files found in the question bank directory.');
        return;
    }

    console.log(`Found ${files.length} CSV files to process.`);

    // Process each CSV file
    const generatedBanks = [];
    const bankNameMap = {};

    for (const file of files) {
        const originalBankName = path.basename(file, '.csv');
        const validIdentifier = toValidIdentifier(originalBankName);
        const filePath = path.join(questionBankDir, file);

        console.log(`Processing ${file}...`);

        // Read and parse CSV
        const csvData = fs.readFileSync(filePath, 'utf-8');
        const bank = parseCSVToQuestionBank(csvData, originalBankName);

        // Generate TypeScript code
        const tsCode = generateTypeScriptCode(bank);

        // Write to file
        const outputPath = path.join(outputDir, `${validIdentifier}.ts`);
        fs.writeFileSync(outputPath, tsCode);

        generatedBanks.push(validIdentifier);
        bankNameMap[validIdentifier] = originalBankName;

        console.log(`Generated ${outputPath}`);
    }

    // Generate index file that exports all banks
    const indexContent = `// Auto-generated index file
// Do not edit this file directly

${generatedBanks.map(bank => `import { ${bank} } from './${bank}';`).join('\n')}

export const questionBanks = [
${generatedBanks.map(bank => `  ${bank},`).join('\n')}
];

export const questionBankNames = {
${Object.entries(bankNameMap).map(([key, value]) => `  ${key}: "${value}",`).join('\n')}
};
`;

    const indexPath = path.join(outputDir, 'index.ts');
    fs.writeFileSync(indexPath, indexContent);

    console.log(`Generated ${indexPath}`);
    console.log('All question banks generated successfully!');
}

// Run the script
generateQuestionBanks(); 